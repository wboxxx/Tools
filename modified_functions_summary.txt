========== FONCTIONS MODIFI√âES ==========

>> __init__ (delta: 377)
--- 
+++ 
@@ -120,373 +120,4 @@
         # === STRUCTURE UI ===

         self.controls_top = Frame(self.root)

         self.controls_top.pack(fill=X, side='top')

-        self.controls_bottom = Frame(self.root)

-        self.controls_bottom.pack(fill=X, side='top')

-

-        self.video_area = Frame(self.root)

-        self.video_area.pack(fill=tk.BOTH, expand=True)

-

-        self.canvas = tk.Canvas(self.video_area, bg='black')

-        self.canvas.pack(fill=tk.BOTH, expand=True)

-        

-        #harmony UI

-        self.harmony_canvas = tk.Canvas(self.root, height=30, bg="#222")

-        self.harmony_canvas.pack(fill="x", side="top", after=self.grid_canvas)

-

-

-        # === GRID FRAME ===

-        self.grid_frame = Frame(self.root)

-        self.grid_frame.pack(side='top', fill='x')

-        self.grid_toggle_button = Button(self.grid_frame, text='Grille ‚ñº', command=self.toggle_grid)

-        self.grid_toggle_button.pack(fill='x')

-        self.grid_canvas = Canvas(self.grid_frame, height=20, bg='white')

-        self.grid_canvas.pack(fill='x')

-

-        # === TIMELINE FRAME ===

-        self.timeline_frame = Frame(self.video_area)

-        self.timeline_frame.pack(side='bottom', fill='x')

-        self.timeline = Canvas(self.timeline_frame, height=24, bg='grey')

-        self.timeline.pack(fill='x')

-        # === TEMPO UI ===

-        self.tempo_frame = Frame(self.controls_top)

-        self.tempo_frame.pack(side='right', padx=10)

-

-        Label(self.tempo_frame, text="üéº Tempo").pack(side=LEFT)

-

-        # Boutons +/- dans frame vertical compact

-        self.tempo_buttons_frame = Frame(self.tempo_frame, width=15, height=20)

-        self.tempo_buttons_frame.pack_propagate(False)

-        self.tempo_buttons_frame.pack(side='left', padx=2)

-

-        self.tempo_up_btn = Button(self.tempo_buttons_frame, text="+", command=self.increase_tempo)

-        self.tempo_up_btn.place(relx=0, rely=0, relwidth=1, relheight=0.5)

-

-        self.tempo_down_btn = Button(self.tempo_buttons_frame, text="-", command=self.decrease_tempo)

-        self.tempo_down_btn.place(relx=0, rely=0.5, relwidth=1, relheight=0.5)

-

-        # Champ tempo √† droite des boutons

-        self.tempo_var = tk.DoubleVar(value=self.tempo_bpm)

-        self.tempo_entry = tk.Entry(self.tempo_frame, textvariable=self.tempo_var, width=5, state="readonly")

-        self.tempo_entry.pack(side=LEFT)

-        self.tempo_entry.bind("<FocusIn>", self._enable_tempo_edit)

-        self.tempo_entry.bind("<Return>", self._on_tempo_enter)

-        self.tempo_entry.bind("<Button-1>", self._on_tempo_click)

-

-

-        tempo_menu_button = tk.Menubutton(self.tempo_frame, text="‚öôÔ∏è √âdition Tempo", relief=tk.RAISED)

-        tempo_menu = tk.Menu(tempo_menu_button, tearoff=0)

-

-        # Fonctions d√©j√† pr√©sentes

-        tempo_menu.add_command(label="ü´∞ Tap Tempo", command=self.tap_tempo)

-        tempo_menu.add_command(label="üéØ Tempo A‚ÄìB", command=self.set_tempo_from_loop)

-        tempo_menu.add_command(label="üîç Analyse Boucle", command=self.analyser_boucle)

-

-        # Multiplicateurs

-        tempo_menu.add_separator()

-        tempo_menu.add_command(label="√ó2", command=lambda: self.modify_tempo(factor=2))

-        tempo_menu.add_command(label="√∑2", command=lambda: self.modify_tempo(factor=0.5))

-        tempo_menu.add_command(label="√ó3", command=lambda: self.modify_tempo(factor=3))

-        tempo_menu.add_command(label="√∑3", command=lambda: self.modify_tempo(factor=1/3))

-

-        tempo_menu_button.config(menu=tempo_menu)

-        tempo_menu_button.pack(side=LEFT, padx=5)

-

-        self.lock_tempo_var = tk.BooleanVar(value=False)

-        Checkbutton(self.tempo_frame, text="üîí Lock", variable=self.lock_tempo_var, command=self.update_video_speed_from_tempo).pack(side=LEFT)

-        self.tempo_label = Label(self.controls_bottom, text="")

-        self.tempo_label.pack(side='right', padx=10)

-

-        # === INIT UI SECTIONS SUPPL√âMENTAIRES ===

-        self.console = Label(self.controls_bottom, text="", anchor=W)

-        self.console.pack(side=LEFT, fill=X, expand=True)

-        self.time_display = Label(self.controls_bottom, text="", anchor=W)

-        self.time_display.pack(side=LEFT, padx=10)

-                

-        #quickopen

-        self.load_recent_files()

-

-

-        # === INIT FLAGS & VARS ===

-        self.playhead_id = None

-

-        self.threshold = 0.5

-        self.beat1 = None

-        self.beat1_locked = False

-        self.loop_start = self.loop_end = None

-        self.grid_times = []

-        self.grid_labels = []

-        self.duration = 0

-        self.step_mode_index = 0

-        self.autostep_enabled = False

-        self.beat1_candidates = []

-        self.playhead_time = None

-        self.use_precise_seek = True

-        self.edit_mode = StringVar(value="playhead")

-        self.snap_to_keyframes_enabled = False

-        self.debug_show_beat_lines_only = False  

-        self.debug_show_grid_lines = True

-        self.GlobApos= None

-        # self.GlobXa = None

-        self.GlobXb = None

-        self.needs_refresh = True

-        self.cached_width = None

-        self.awaiting_vlc_jump = False

-        self.freeze_interpolation = False

-        self.last_seek_time = 0

-

-

-

-        

-        # === DEMARRAGE ===

-        self.root.after(100, self.update_loop)

-        self.safe_update_playhead(0, source="INIT")

-        self.force_playhead_time = False

-        self.last_jump_target_ms = 0

-        self.ram_audio_start_time = None

-

-        # === RESULT BOX ===

-        self.result_visible = False  # doit √™tre AVANT le pack

-

-        self.result_frame = Frame(self.root)

-

-        self.result_box = tk.Text(self.result_frame,

-                                  height=14,

-                                  bg='black',

-                                  fg='white',

-                                  font=("Courier New", 16),

-                                  takefocus=0,

-                                  cursor='arrow')

-        self.result_box.pack(fill=tk.BOTH, expand=True)

-

-        # ‚ùå Supprime cette ligne :

-        # self.result_frame.pack(fill=tk.BOTH, expand=True)

-

-        # ‚úÖ Ne pack que si visible :

-        if self.result_visible:

-            self.result_frame.pack(fill=tk.BOTH, expand=True)

-

-        self.result_box.bind("<Button-1>", self.on_result_click)

-        self.result_box.config(state='disabled')

-

-        # === CONTROLS PRINCIPAUX ===

-

-        # === MENUS ET CONTR√îLES BOTTOM ===

-        self.loop_length_var = tk.IntVar(value=2)  # 2 mesures par d√©faut

-        loop_length_menu = tk.OptionMenu(self.controls_bottom, self.loop_length_var, *range(1, 21))

-        loop_length_menu.config(width=5)

-        loop_length_menu.pack(side=LEFT)

-        ToolTip(loop_length_menu, "D√©finir la longueur de la boucle (en mesures)")

-

-        self.label_subdivision = Label(self.controls_bottom, text="Subdivision: -", width=18)

-        self.label_subdivision.pack(side=LEFT)

-

-        self.conf_slider = tk.Scale(self.controls_bottom, from_=0, to=100, resolution=1, orient=tk.HORIZONTAL, command=self.update_threshold)

-        self.conf_slider.set(50)

-        self.conf_slider.pack(side=LEFT)

-

-        self.beat1_selector_var = tk.StringVar(value="Beat 1")

-        self.beat1_selector = tk.OptionMenu(self.controls_bottom, self.beat1_selector_var, "Beat 1")

-        self.beat1_selector.pack(side=LEFT)

-

-        #OPEN MENU

-        control_buttons = [

-            ("üìÇ", lambda: self.show_open_menu(), "Ouvrir un fichier"),

-        ]

-        for txt, cmd, tip in control_buttons:

-            btn = Button(self.controls_top, text=txt, command=cmd, width=5)

-            btn.pack(side=LEFT)

-            ToolTip(btn, tip)

-

-        #LOOP MENU

-        self.loop_menu_button = tk.Menubutton(self.controls_top, text="üîÅ Boucle", relief=tk.RAISED)

-        self.loop_menu = tk.Menu(self.loop_menu_button, tearoff=0)

-        self.loop_menu_button.config(menu=self.loop_menu)

-        self.loop_menu_button.pack(side=LEFT, padx=5)

-        ToolTip(self.loop_menu_button, "Actions li√©es aux boucles et √† leur analyse")

-        # === BOUTONS A / B ===

-        self.btn_edit_A = Button(self.controls_top, text="A", command=lambda: self.set_edit_mode("loop_start"), width=3)

-        self.btn_edit_A.pack(side=LEFT)

-        ToolTip(self.btn_edit_A, "√âditer A")

-

-        self.btn_edit_B = Button(self.controls_top, text="B", command=lambda: self.set_edit_mode("loop_end"), width=3)

-        self.btn_edit_B.pack(side=LEFT)

-        ToolTip(self.btn_edit_B, "√âditer B")

-        #OPEN MENU 2/2

-        control_buttons = [

-            ("‚ñ∂Ô∏è", self.toggle_playpause_icon, "Lecture/Pause"),

-        ]

-        for txt, cmd, tip in control_buttons:

-            btn = Button(self.controls_top, text=txt, command=cmd, width=5)

-            btn.pack(side=LEFT)

-            ToolTip(btn, tip)

-        # === Sous-menu STEP ===

-        self.step_menu_button = tk.Menubutton(self.controls_top, text="üé¨ Step", relief=tk.RAISED)

-        self.step_menu = tk.Menu(self.step_menu_button, tearoff=0)

-        self.step_menu.add_command(label="‚óÄ‚óÄ Retour en arri√®re", command=self.step_back)

-        self.step_menu.add_command(label="‚ñ∂‚ñ∂ Lecture pas √† pas", command=self.step_play)

-        self.step_menu.add_command(label="üîÅ Lecture auto steps", command=self.toggle_autostep)

-        self.step_menu_button.config(menu=self.step_menu)

-        self.step_menu_button.pack(side=LEFT, padx=5)

-        

-

-        # === BOUTON R√âSULTATS ===

-        self.toggle_result_btn = Button(self.controls_bottom, text="üîΩ", command=self.toggle_result_box, width=3)

-        self.toggle_result_btn.pack(side=LEFT)

-

-        ToolTip(self.toggle_result_btn, "Afficher/masquer les r√©sultats")

-

-        # --- Ajout bouton pour v√©rifier/reencoder GOP ---

-

-

-

-

-        #zoom screen button         

-        self.zoom_menu_button = tk.Menubutton(self.controls_top, text="üîç Zoom", relief=tk.RAISED)

-        self.zoom_menu = tk.Menu(self.zoom_menu_button, tearoff=0)

-        self.build_screen_zoom_menu(self.zoom_menu)

-        self.zoom_menu_button.config(menu=self.zoom_menu)

-        self.zoom_menu_button.pack(side=tk.LEFT, padx=5)

-

-

-        # Fonctions de zoom et navigation

-        # zoom_menu.add_command(label="üîç+ Zoom avant", command=self.zoom_in)

-        # zoom_menu.add_command(label="üîé‚àí Zoom arri√®re", command=self.zoom_out)

-        # zoom_menu.add_separator()

-        # zoom_menu.add_command(label="‚¨ÖÔ∏è D√©placer √† gauche", command=self.pan_left)

-        # zoom_menu.add_command(label="‚û°Ô∏è D√©placer √† droite", command=self.pan_right)

-        # zoom_menu.add_separator()

-        # zoom_menu.add_command(label="üîÑ R√©initialiser", command=self.reset_crop)

-

-        # zoom_menu_button.config(menu=zoom_menu)

-        # zoom_menu_button.pack(side=LEFT, padx=5)

-        # ToolTip(zoom_menu_button, "Zoom et navigation horizontale")

-

-            

-            

-         

-        # ZOOMVIDEO

-        self.saved_loops = []

-        self.timeline_saved_loop_tags = {}

-        self.global_zoom_level = 1.0

-        self.global_crop_x = 0

-        self.global_crop_y = 0

-        self.zoom_step = 0.1

-        self.pan_step = 50

-        self.edit_mode_zoom = False  

-        self.saved_zoom_level = None

-        self.saved_crop_x = None

-        self.saved_crop_y = None

-

-

-        # Cr√©ation du cadre vid√©o dans le canvas

-        self.video_frame = Frame(self.canvas, width=1920, height=1080)

-        self.video_frame.pack()

-        self.video_frame.place(x=0, y=0)

-

-        self.instance = vlc.Instance()

-        self.player = self.instance.media_player_new()

-        self.player.set_hwnd(self.video_frame.winfo_id())

-

-

-        

-        # === TIMELINE EVENTS

-        self.edit_mode = StringVar(value="playhead")

-

-        #zoomAB SLIDER

-        from tkinter import Scale

-

-        # === RHYTHM CONTROLS FRAME ===

-        self.rhythm_controls_frame = Frame(self.controls_top)

-        self.rhythm_controls_frame.pack(side='left', padx=5)

-        self.zoom_slider = Scale(self.rhythm_controls_frame, from_=0.1, to=1.0, resolution=0.05, orient='horizontal', label='ZoomAB', showvalue=False,  length=60, sliderlength=10, width=8, font=("Arial", 6), command=self.on_zoom_change)

-        self.zoom_slider.bind("<Double-Button-1>", lambda e: self.reset_zoom_slider())

-        self.zoom_slider.set(self.loop_zoom_ratio)

-        self.zoom_slider.pack(side='left', padx=5)

-        

-        

-        # === BINDINGS CLAVIER PRINCIPAUX ===

-        #note display

-        self.root.bind("<Shift-Tab>", lambda e: self.cycle_note_display_mode())

-

-        

-        #quicksave

-        self.root.bind("<Control-s>", self.quick_save_current_loop)

-

-        

-        #heatmap

-        self.root.bind("<period>", lambda e: self.reset_syllabic_grid_hits())

-

-        

-        #zoom bindings screen

-        

-        self.root.bind_all('<Key>', self.handle_screen_zoom_keypress)

-        # self.root.bind("<Shift-Tab>", lambda e: self.cycle_subdivision_mode_backward())

-        self.root.bind("<Tab>", lambda e: self.cycle_subdivision_mode())

-        self.loop_menu_button.bind("<Button-1>", lambda e: self.update_loop_menu())

-        # self.root.bind("<F4>", self.edit_current_chord_from_playhead)

-        self.root.bind("<F4>", lambda e: self.open_chord_editor_all())

-        

-        self.root.bind("<F10>", self.start_profiling_5s)

-        # self.root.bind("<F9>", self.dump_playhead_debug_log())

-

-        self.root.bind('<F9>', lambda e: self.dump_playhead_debug_log())

-        self.root.bind('<space>', lambda e: self.toggle_pause())

-        # self.root.bind('<Right>', lambda e: self.jump(10))

-        # self.root.bind('<Left>', lambda e: self.jump(-10))

-        # self.root.bind('<Shift-Right>', lambda e: self.jump(1))

-        # self.root.bind('<Shift-Left>', lambda e: self.jump(-1))

-        # self.root.bind('<Control-Right>', lambda e: self.jump(60))

-        # self.root.bind('<Control-Left>', lambda e: self.jump(-60))

-        # self.root.bind('<Alt-Right>', lambda e: self.jump(600))

-        # self.root.bind('<Alt-Left>', lambda e: self.jump(-600))

-        # self.root.bind('<Control-Shift-Right>', lambda e: self.precise_jump(0.1))

-        # self.root.bind('<Control-Shift-Left>', lambda e: self.precise_jump(-0.1))

-        self.root.bind("<Left>", lambda e: self.jump_playhead(-1, "beat"))

-        self.root.bind("<Right>", lambda e: self.jump_playhead(+1, "beat"))

-        self.root.bind("<Shift-Left>", lambda e: self.jump_playhead(-1, "8th"))

-        self.root.bind("<Shift-Right>", lambda e: self.jump_playhead(+1, "8th"))

-        self.root.bind("<Control-Left>", lambda e: self.jump_playhead(-1, "bar"))

-        self.root.bind("<Control-Right>", lambda e: self.jump_playhead(+1, "bar"))

-        self.root.bind("<Control-Shift-Left>", lambda e: self.jump_playhead(-1, "16th"))

-        self.root.bind("<Control-Shift-Right>", lambda e: self.jump_playhead(+1, "16th"))

-        self.root.bind("<Alt-Control-Shift-Left>", lambda e: self.jump_playhead(-1, "64th"))

-        self.root.bind("<Alt-Control-Shift-Right>", lambda e: self.jump_playhead(+1, "64th"))

-        self.root.bind("r", lambda e: self.replay_from_A())

-        self.timeline.bind("<Button-1>", self.on_timeline_click)

-        self.timeline.bind("<B1-Motion>", self.on_timeline_drag)

-        self.timeline.bind("<Configure>", self.on_timeline_resize)

-

-

-

-

-        self.root.bind('<Key-q>', lambda e: self.cycle_chord_harmony_mode())

-        self.root.bind('<Shift-Q>', lambda e: self.cycle_note_harmony_mode())

-        self.root.bind('<Key-plus>', lambda e: self.adjust_speed(0.1))

-        self.root.bind('<Key-minus>', lambda e: self.adjust_speed(-0.1))

-        self.root.bind('<Up>', lambda e: self.adjust_volume(10))

-        self.root.bind('<Down>', lambda e: self.adjust_volume(-10))

-        self.root.bind('<Key-a>', lambda e: self.set_edit_mode("loop_start"))

-        self.root.bind('<Key-b>', lambda e: self.set_edit_mode("loop_end"))

-        self.root.bind('<Control-Return>', lambda e: self.reset_speed())

-        self.root.bind('<Key-s>', lambda e: self.stop_and_return())

-        self.root.bind("<Shift-A>", lambda e: self.jump_to_A())

-        # self.root.bind('<Key-r>', lambda e: self.toggle_loop())

-        self.root.bind('<Shift-T>', lambda e: self.toggle_autostep())

-        self.root.bind('<Key-t>', lambda e: self.step_play())

-        self.root.bind('<Shift-A>', lambda e: self.record_loop_marker("loop_start", auto_exit=True))

-        self.root.bind('<Shift-B>', lambda e: self.record_loop_marker("loop_end", auto_exit=True))

-        self.root.bind("<Shift-C>", self.clear_loop)

-        self.root.bind('<Key-l>', lambda e: self.analyser_boucle())

-        self.root.bind('<Key-l>', lambda e: self.analyser_boucle())

-        self.root.bind('<Key-h>', lambda e: self.load_hotspot_candidates())

-        self.root.bind('<Key-m>', lambda e: self.place_marker())

-        self.root.bind('<Shift-M>', lambda e: self.remove_last_marker())

-        self.root.bind('<Key-Escape>', lambda e: self.clear_edit_mode())

-        self.root.bind('<Key-c>', lambda e: self.center_on_playhead())

-        self.root.bind('<Shift-O>', lambda e: self.start_ram_loop())

-        self.root.bind('<Shift-P>', lambda e: self.stop_ram_loop())

-

-        # Charger le zoom pr√©c√©dent si existant

-        # self.load_screen_zoom_prefs() 

-        self.try_auto_load_recent_file()

-    

+        self.controls_bottom = Frame(self.root


>> export_loop_and_upload_to_drive (delta: 136)
--- 
+++ 
@@ -15,118 +15,26 @@
         Brint(f"üéß Export de la boucle : {self.loop_start:.2f} ms ‚Üí {self.loop_end:.2f} ms ‚Üí {export_path}")

 

         start_sec = self.loop_start / 1000.0

-        success = False

+

+        cmd = [

+            "ffmpeg", "-y",

+            "-ss", str(start_sec),

+            "-t", str(duration_sec),

+            "-i", self.current_path,

+            "-vn",

+            "-acodec", "pcm_s16le",

+            "-ar", "48000",

+            "-ac", "2"

+        ]

 

         if repeat:

-            # Keep existing complex ffmpeg command for repeat

-            # cmd = [

-                # "ffmpeg", "-y",

-                # "-ss", str(start_sec),

-                # "-t", str(duration_sec), # Note: duration_sec was already multiplied by 10 if repeat

-                # "-i", self.current_path,

-                # "-vn",

-                # "-acodec", "pcm_s16le", # Outputting to WAV first for the loop filter

-                # "-ar", "48000",

-                # "-ac", "2",

-                # "-filter_complex", "aloop=loop=9:size=1:start=0", # This implies the input duration should be the single loop

-                                                                # # and ffmpeg handles repeating it.

-                                                                # # So, duration_sec for -t should be the single loop duration.

-                                                                # # The original code had duration_sec multiplied by 10 *before* this.

-                                                                # # Let's adjust duration_sec if repeat is true for the -t param.

-                # # The actual duration for -t should be the original single loop duration.

-                # # The -stream_loop or aloop filter handles the repetition.

-                # # The initial duration_sec calculation was:

-                # # duration = self.loop_end - self.loop_start

-                # # duration_sec = duration / 1000.0

-                # # if repeat: duration_sec *= 10 

-                # # This means for the -t parameter, we need the original non-multiplied duration.

-            single_loop_duration_sec = (self.loop_end - self.loop_start) / 1000.0

-            # ]

-            # Reconstruct command for repeat scenario carefully

-            cmd = [

-                "ffmpeg", "-y",

-                "-ss", str(start_sec),

-                "-t", str(single_loop_duration_sec), # Use single loop duration for input segment

-                "-i", self.current_path,

-                "-filter_complex", f"aloop=loop=9:size={int(single_loop_duration_sec * 48000 * 2 * 2)}", # Approximation for size in samples

-                "-vn", # No video

-                "-acodec", "pcm_s16le", # Output format

-                "-ar", "48000", # Sample rate

-                "-ac", "2", # Channels

-                export_path # Output path

-            ]

-            # The above aloop size is problematic. A better approach for repeating a segment is to extract it first, then concat.

-            # However, to minimize changes to the repeat logic for now, let's stick to a direct ffmpeg call

-            # if the original intent was to use ffmpeg's looping for WAV export.

-            # Given `export_loop_to_file` uses pydub for WAV repeat, it's likely this `aloop` was for something else or video.

-            # For WAV export to GDrive with repeat, it might be better to use pydub then upload.

-            # Sticking to the task: only change non-repeat. The existing repeat logic for ffmpeg here seems overly complex

-            # for simple WAV repeat and might be a leftover or misinterpretation.

-            # For now, let's assume the original complex command for repeat should be preserved if it worked.

-            # The problem is that `duration_sec` was already multiplied by 10.

-            # If `aloop` is to work on the *original* segment, then `-t` should be `single_loop_duration_sec`.

+            cmd += ["-filter_complex", "aloop=loop=9:size=1:start=0", "-map", "[a]"]

 

-            # Reverting to a slightly modified version of original if repeat=True, assuming it was functional for a specific ffmpeg version/need

-            # This part is tricky because the original logic for `duration_sec` and `aloop` might be subtly intertwined.

-            # The safest change is to only touch the non-repeat path.

+        cmd += [export_path]

 

-            # Preserving the original complex command for `repeat=True` as accurately as possible,

-            # but noting that `duration_sec` here is already 10x the loop.

-            # This `aloop` filter might be intended for video stream looping if this function was ever used for video.

-            # Given it's `export_loop_and_upload_to_drive` and uploads `temp_loop.wav`, it implies audio.

-            

-            # Corrected approach for ffmpeg repeat:

-            # 1. Extract single loop segment

-            # 2. Use that segment as input to another ffmpeg command with -loop (for image sequences) or -stream_loop (for audio/video)

-            # This is getting too complex for this sub-task. Let's only refactor the non-repeat part.

+        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

 

-            Brint("[EXPORT GDRIVE] Using direct ffmpeg for repeat=True case due to complex filter.")

-            cmd_original_repeat = [

-                "ffmpeg", "-y",

-                "-ss", str(start_sec),

-                "-t", str((self.loop_end - self.loop_start) / 1000.0), # Use single loop duration for input

-                "-i", self.current_path,

-                "-filter_complex", "aloop=loop=9:size=2000000000", # Large size to accommodate loop, actual size calculation is complex

-                "-vn",

-                "-acodec", "pcm_s16le",

-                "-ar", "48000",

-                "-ac", "2",

-                export_path

-            ]

-            try:

-                subprocess.run(cmd_original_repeat, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE, check=True)

-                success = True

-            except subprocess.CalledProcessError as e:

-                Brint(f"‚ùå FFmpeg failed for GDrive repeat export: {e.stderr.decode(errors='ignore')}")

-                success = False

-

-        else: # repeat == False

-            extracted_path_util = _util_extract_audio_segment(

-                source_path=self.current_path,

-                output_path=export_path,

-                start_sec=start_sec,

-                duration_sec=duration_sec, # This is single loop duration

-                audio_codec="pcm_s16le",

-                sample_rate=48000,

-                channels=2,

-                overwrite=True,

-                use_temp_file=False # export_path is provided

-            )

-            if extracted_path_util:

-                success = True

-            else:

-                Brint(f"‚ùå √âchec de l'export audio (repeat=False) dans export_loop_and_upload_to_drive")

-                success = False

-        

-        if success:

-            upload_loop_to_drive(export_path, media_base_name)

-        else:

-            self.console.config(text="‚ùå Erreur export GDrive")

-            if os.path.exists(export_path):

-                try:

-                    os.remove(export_path) # Clean up failed export

-                except OSError as e:

-                    Brint(f"Could not remove failed GDrive export at {export_path}: {e}")

+        upload_loop_to_drive(export_path, media_base_name)

 

         #GDRIVE CALLER ENDS

     


>> predict_on_loop_segment (delta: 93)
--- 
+++ 
@@ -1,47 +1,40 @@
 def predict_on_loop_segment(original_path, beat1_sec, duration_sec):

     Brint(f"üéß Extraction de {duration_sec}s √† partir de {beat1_sec}s...")

 

-    # Use the new utility to extract the segment directly to a temporary WAV file

-    temp_segment_path = _util_extract_audio_segment(

-        source_path=original_path,

-        start_sec=beat1_sec,

-        duration_sec=duration_sec,

-        sample_rate=44100, # basic_pitch default

-        channels=1,        # basic_pitch default

-        use_temp_file=True # Important to get a temp file path

-    )

+    # Si le fichier est une vid√©o, extraire l'audio en WAV

+    if original_path.lower().endswith('.mp4'):

+        temp_audio = original_path + ".extracted.wav"

+        if not os.path.exists(temp_audio):

+            cmd = [

+                "ffmpeg",

+                "-i", original_path,

+                "-vn",  # no video

+                "-acodec", "pcm_s16le",

+                "-ar", "44100",

+                "-ac", "1",

+                temp_audio

+            ]

+            subprocess.run(cmd, check=True)

+        audio_path = temp_audio

+    else:

+        audio_path = original_path

 

-    if not temp_segment_path:

-        Brint(f"[PREDICT ON LOOP] ‚ùå Failed to extract audio segment for {original_path}")

-        return None, None, None

+    # Charger tout le fichier audio avec soundfile

+    y_full, sr = sf.read(audio_path, always_2d=False)

 

-    # Get duration of the extracted segment for Brint

-    try:

-        # Attempt to load with librosa to get duration; basic_pitch might not expose this easily

-        y_segment, sr_segment = librosa.load(temp_segment_path, sr=None)

-        segment_actual_duration_s = librosa.get_duration(y=y_segment, sr=sr_segment)

-        Brint(f"üéß Analyse de {os.path.basename(temp_segment_path)} (dur√©e {segment_actual_duration_s:.2f}s)")

-    except Exception as e:

-        Brint(f"üéß Analyse de {os.path.basename(temp_segment_path)} (dur√©e {duration_sec:.2f}s - fallback Brint)")

+    # Convertir temps en samples

+    start_sample = int(beat1_sec * sr)

+    end_sample = int((beat1_sec + duration_sec) * sr)

 

+    # Extraction du segment

+    y = y_full[start_sample:end_sample]

 

-    # Analyse avec Basic Pitch

-    start_predict = time.time()

-    try:

-        model_output, midi_data, note_events = predict(

-            temp_segment_path, # Use the extracted segment

-            model_or_model_path=ICASSP_2022_MODEL_PATH,

-            onset_threshold=0.3,

-            frame_threshold=0.3,

-            minimum_note_length=30.0,

-            minimum_frequency=70.0,

-            maximum_frequency=1300.0,

-            melodia_trick=True

-        )

-    except Exception as e:

-        Brint(f"[PREDICT ON LOOP] ‚ùå Basic Pitch prediction failed: {e}")

-        os.remove(temp_segment_path) # Clean up temp file

-        return None, None, None

+    # Sauvegarder le segment dans un WAV temporaire

+    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tmpfile:

+        temp_path = tmpfile.name

+        sf.write(temp_path, y, sr)

+

+    Brint(f"üéß Analyse de {os.path.basename(temp_path)} (dur√©e {len(y)/sr:.2f}s)")

 

     # Analyse avec Basic Pitch

     start_predict = time.time()

@@ -58,10 +51,10 @@
     Brint(f"[TIMER] Predict: {time.time() - start_predict:.2f}s")

 

     adjusted_events = [

-        (start + beat1_sec, end + beat1_sec, pitch, conf, extra) # Adjust timestamps relative to original file

+        (start + beat1_sec, end + beat1_sec, pitch, conf, extra)

         for start, end, pitch, conf, extra in note_events

     ]

 

-    os.remove(temp_segment_path) # Clean up the temporary segment file

+    os.remove(temp_path)

     return model_output, midi_data, adjusted_events

 


>> extract_keyframes (delta: 73)
--- 
+++ 
@@ -1,57 +1,25 @@
-    def extract_keyframes(self, path, start_time_sec=None, duration_sec=None, end_time_sec=None):

-        """

-        Extrait les timestamps (en secondes) des keyframes (I-frames) du fichier vid√©o.

-        Optionally filters for keyframes within a given time window.

-        """

+    def extract_keyframes(self, path):

+        """Extrait les timestamps (en secondes) des keyframes (I-frames) du fichier vid√©o."""

         cmd = [

             "ffprobe",

-            "-v", "error", # Reduce verbosity

             "-select_streams", "v:0",

-            "-show_entries", "frame=pkt_pts_time,pict_type", # pict_type to identify I-frames

-            "-of", "csv=p=0", # No header, comma-separated

+            "-show_frames",

+            "-show_entries", "frame=pkt_pts_time,best_effort_timestamp_time,pict_type",

+            "-of", "csv",

             path

         ]

         try:

-            output = subprocess.check_output(cmd, stderr=subprocess.PIPE).decode()

-            all_keyframes = []

+            output = subprocess.check_output(cmd, stderr=subprocess.DEVNULL).decode()

+            keyframes = []

             for line in output.splitlines():

                 parts = line.strip().split(",")

-                if len(parts) == 2 and parts[1] == "I": # pkt_pts_time,pict_type

-                    try:

-                        time_sec = float(parts[0])

-                        all_keyframes.append(time_sec)

-                    except ValueError:

-                        Brint(f"[KEYFRAME_PARSE_WARN] Could not parse time from ffprobe line: {line}")

-                        continue

-            

-            if not all_keyframes:

-                Brint(f"‚ö†Ô∏è Aucune keyframe trouv√©e avec ffprobe pour {path}.")

-                return []

-

-            # Apply filtering if time window is specified

-            if start_time_sec is not None:

-                # Determine the actual end time for filtering

-                actual_end_time_sec = float('inf')

-                if duration_sec is not None:

-                    actual_end_time_sec = start_time_sec + duration_sec

-                elif end_time_sec is not None: # Allow specifying end_time_sec directly

-                    actual_end_time_sec = end_time_sec

-

-                filtered_keyframes = [

-                    kf for kf in all_keyframes

-                    if start_time_sec <= kf < actual_end_time_sec # Use < for end for consistency with -t in ffmpeg

-                ]

-                Brint(f"‚úÖ {len(all_keyframes)} keyframes totales. {len(filtered_keyframes)} dans la fen√™tre [{start_time_sec:.2f}s - {actual_end_time_sec:.2f}s).")

-                return sorted(list(set(filtered_keyframes))) # Ensure uniqueness and order

-            else:

-                Brint(f"‚úÖ {len(all_keyframes)} keyframes extraites (total).")

-                return sorted(list(set(all_keyframes)))

-

-        except subprocess.CalledProcessError as e:

-            Brint(f"‚ùå Erreur ffprobe (CalledProcessError) pour keyframes: {e.stderr.decode(errors='ignore') if e.stderr else e}")

-            return []

+                if len(parts) == 3 and parts[2] == "I":

+                    time_sec = float(parts[1])

+                    keyframes.append(time_sec)

+            Brint(f"‚úÖ {len(keyframes)} keyframes extraites")

+            return keyframes

         except Exception as e:

-            Brint(f"‚ùå Erreur g√©n√©rale extraction keyframes: {e}")

+            Brint(f"‚ùå Erreur extraction keyframes: {e}")

             return []

 

 


>> jump_playhead (delta: 65)
--- 
+++ 
@@ -1,52 +1,30 @@
     def jump_playhead(self, direction, level):

         assert direction in (-1, 1), "Direction must be +1 or -1"

-

-        original_level = level

-        override_reason = ""

-

-        if not self.is_loop_effectively_defined():

-            # üîÅ Aucun loop actif ‚Üí override dur√©es en SECONDES

-            override_seconds = {

-                "beat": 10,

-                "8th": 60,

-                "16th": 300,

-                "64th": 600

-            }

-            seconds = override_seconds.get(level, None)

-            if seconds is not None:

-                delta_ms = int(seconds * 1000)

-                override_reason = f"[NO LOOP] override {original_level} ‚Üí {seconds:.3f}s"

-                Brint(f"[JUMP] Aucun loop actif ‚Üí {original_level} remplac√© par {seconds:.3f}s ({delta_ms} ms)")

-            else:

-                delta_ms = self.get_jump_duration_ms(level)

-        else:

-            delta_ms = self.get_jump_duration_ms(level)

-

+        

+        delta_ms = self.get_jump_duration_ms(level)

+        

         mode = self.edit_mode.get() if hasattr(self, "edit_mode") else None

 

         if mode == "loop_start" and self.loop_start is not None:

             current_ms = self.loop_start

-            Brint("[JUMP] Mode √©dition : loop_start")

         elif mode == "loop_end" and self.loop_end is not None:

             current_ms = self.loop_end

-            Brint("[JUMP] Mode √©dition : loop_end")

         else:

             current_ms = int(self.playhead_time * 1000)

-            Brint(f"[JUMP] Mode normal depuis {current_ms} ms")

 

-        target_ms = current_ms + direction * delta_ms

+        target_ms = current_ms + direction * int(delta_ms)

         target_ms = self.snap_time_to_grid(target_ms, level)

         target_ms = max(0, target_ms)

 

+        # üéØ Mise √† jour en respectant le mode

         if mode == "loop_start":

             self.record_loop_marker("loop_start", milliseconds=target_ms, auto_exit=False)

         elif mode == "loop_end":

             self.record_loop_marker("loop_end", milliseconds=target_ms, auto_exit=False)

         else:

-            self.safe_jump_to_time(target_ms, source="jump_playhead")

-            self.safe_update_playhead(target_ms, source="jump_playhead")

+            # self.jump_to_time(target_ms)

+            self.safe_jump_to_time(int(target_ms), source="jump_playhead")

+            self.safe_update_playhead(int(target_ms), source="jump_playhead")

 

-        Brint(f"‚û°Ô∏è Jump {original_level} {direction:+} ‚Üí {target_ms} ms (delta : {delta_ms} ms) {override_reason}")

-

-

-

+        # ‚úÖ Ajout du delta r√©el affich√© (utile pour v√©rifier la r√©versibilit√© imm√©diate)

+        Brint(f"‚û°Ô∏è Jump {level} {direction:+} ‚Üí {target_ms} ms (delta demand√© : {int(delta_ms)} ms)")


>> predict_on_interval (delta: 61)
--- 
+++ 
@@ -1,42 +1,13 @@
 def predict_on_interval(filepath, beat1_sec, bpm, measures=20, tmp_path="temp_segment.wav"):

     """D√©coupe un fichier audio de beat1 jusqu'√† beat1 + N mesures, et ex√©cute Basic Pitch dessus."""

     try:

-        duration_sec = measures * (60 / bpm) * 4  # 4 beats/measure

+        seconds = measures * (60 / bpm) * 4  # 4 beats/measure

+        y, sr = librosa.load(filepath, sr=None, offset=beat1_sec, duration=seconds)

+        sf.write(tmp_path, y, sr)

 

-        # Use the new utility to extract the segment

-        # If tmp_path is "temp_segment.wav", it will be created in the current working directory.

-        # It's better to let _util_extract_audio_segment handle temp file creation if no path is given,

-        # or ensure tmp_path is a full path to a desired temp location.

-        # For now, assuming tmp_path="temp_segment.wav" is intended for current dir.

-        

-        # Ensure tmp_path is cleaned up even if _util_extract_audio_segment creates it

-        # However, standard usage of _util_extract_audio_segment with use_temp_file=True

-        # would return a path from tempfile.gettempdir().

-        # Let's assume for now that if tmp_path is "temp_segment.wav", it's a deliberate choice for this function.

-        # If we want _util_extract_audio_segment to manage the temp file entirely:

-        # segment_to_analyze = _util_extract_audio_segment(

-        #     source_path=filepath, 

-        #     start_sec=beat1_sec, 

-        #     duration_sec=duration_sec,

-        #     # Defaults for sr, channels, codec are fine for basic_pitch

-        # )

-        # For minimal change, we'll use the provided tmp_path as output_path

-        segment_to_analyze = _util_extract_audio_segment(

-            source_path=filepath,

-            output_path=tmp_path, # Will use the default "temp_segment.wav"

-            start_sec=beat1_sec,

-            duration_sec=duration_sec,

-            use_temp_file=False # We are providing output_path

-        )

-

-

-        if not segment_to_analyze:

-            Brint(f"[PREDICT ON INTERVAL] ‚ùå Failed to extract audio segment for {filepath}")

-            return None, None, None

-

-        Brint(f"üéß Analyse de {segment_to_analyze} (dur√©e {duration_sec:.2f}s)")

+        Brint(f"üéß Analyse de {tmp_path} (dur√©e {seconds:.2f}s)")

         model_output, midi_data, note_events = predict(

-            segment_to_analyze,

+            tmp_path,

             model_or_model_path=ICASSP_2022_MODEL_PATH,

             onset_threshold=0.3,

             frame_threshold=0.3,

@@ -44,9 +15,6 @@
         )

         return model_output, midi_data, note_events

     finally:

-        # The segment_to_analyze is tmp_path. If _util_extract_audio_segment created it because

-        # tmp_path was None, then it should be cleaned. But here tmp_path is a default arg.

-        # This finally block will try to remove it if it exists.

-        if os.path.exists(tmp_path): # Check if tmp_path (e.g. "temp_segment.wav") exists

+        if os.path.exists(tmp_path):

             os.remove(tmp_path)

 


>> open_chord_editor_all (delta: 57)
--- 
+++ 
@@ -32,9 +32,51 @@
         Brint(f"[DEBUG] ‚Üí {len(subdiv_mapping)} subdivisions avec notes mapp√©es")

 

         popup = tk.Toplevel(self.root)

-        popup.transient(self.root) 

         popup.title(f"Modifier accords/notes de '{self.current_loop.name}' (key={self.current_loop.key})")

 

-        self._chord_editor_canvas = tk.Canvas(popup) 

-        self._chord_editor_scrollbar = tk.Scrollbar(popup, orient="vertical", command=self._chord_editor_canvas.yview)

+        beats_per_measure = 4

+        subdivs_per_beat = self.subdivs_per_beat

+        total_subdivs = len(self.grid_subdivs)

+        subdivs_per_measure = beats_per_measure * subdivs_per_beat

+        if subdivs_per_measure == 0:

+            Brint("[ERROR] subdivs_per_measure est 0 ‚Äî impossible de diviser.")

+            return

+        total_measures = (total_subdivs + subdivs_per_measure - 1) // subdivs_per_measure

 

+

+

+        # üî¢ Ajustement dynamique de la largeur du popup selon le nombre de mesures

+        width_per_measure = 160  # ‚ÜîÔ∏è tu peux ajuster ici selon la densit√© visuelle voulue

+        padding = 80  # marge fixe (scrollbar + bords)

+        popup_width = total_measures * width_per_measure + padding

+        popup.geometry(f"{popup_width}x700")

+        Brint(f"[POPUP WIDTH] üìê {total_measures} mesures √ó {width_per_measure}px + {padding}px = {popup_width}px")

+

+

+

+

+        # popup.geometry("800x700")  # hauteur plus g√©n√©reuse

+        popup.attributes("-topmost", True)

+        # üéº Champ √©ditable pour la cl√© de la boucle

+        # key_frame = tk.Frame(popup)

+        # key_frame.pack(pady=5)

+        # tk.Label(key_frame, text="üéº Tonalit√© (key):", font=("Arial", 9)).pack(side="left")

+        mode_var = tk.StringVar(value=self.current_loop.mode or "ionian")

+        key_var = tk.StringVar(value=self.current_loop.key or "C")

+        # tk.Entry(key_frame, textvariable=key_var, width=10).pack(side="left")

+        # Scrollable canvas

+        container = tk.Frame(popup)

+        container.pack(fill="both", expand=True)

+

+        canvas = tk.Canvas(container)

+        scrollbar = tk.Scrollbar(container, orient="vertical", command=canvas.yview)

+        scrollbar.pack(side="right", fill="y")

+        canvas.pack(side="left", fill="both", expand=True)

+

+        canvas.configure(yscrollcommand=scrollbar.set)

+        canvas.bind('<Configure>', lambda e: canvas.itemconfig("frame", width=e.width))

+

+        scrollable_frame = tk.Frame(canvas)

+        scrollable_frame_id = canvas.create_window((0, 0), window=scrollable_frame, anchor="nw", tags="frame")

+

+        # Scroll region auto-ajust√©e


>> extract_keyframes_around (delta: 53)
--- 
+++ 
@@ -1,17 +1,37 @@
     def extract_keyframes_around(self, path, center_time_sec, window_sec=2.0):

         """Extrait pr√©cis√©ment les timestamps des I-frames dans une fen√™tre autour d'un timestamp donn√©."""

-        req_start_time = max(0, center_time_sec - window_sec / 2.0)

-        # req_duration_sec = window_sec # Correctly calculate end time for filtering

-        # Brint(f"extract_keyframes_around: path={path}, center={center_time_sec}, window={window_sec} => start={req_start_time}, duration={req_duration_sec}")

-        # keyframes = self.extract_keyframes(path, start_time_sec=req_start_time, duration_sec=req_duration_sec)

-        # For extract_keyframes, it's better to provide start and end if filtering is post-probe

-        req_end_time_sec = req_start_time + window_sec

-        Brint(f"extract_keyframes_around: path={path}, center={center_time_sec}, window={window_sec} => start={req_start_time}, end={req_end_time_sec}")

-        

-        # Call the enhanced extract_keyframes (assuming it's a method of the same class or globally accessible)

-        # If it's a global function not part of the class, call directly: extract_keyframes(...)

-        keyframes = self.extract_keyframes(path, start_time_sec=req_start_time, end_time_sec=req_end_time_sec)

+        import subprocess

 

-        Brint(f"‚úÖ Keyframes autour de {center_time_sec:.3f}s (fen√™tre {window_sec:.2f}s): {keyframes}")

-        return keyframes

+        start_time = max(0, center_time_sec - window_sec / 2)

+        duration = window_sec

 

+        cmd = [

+            "ffmpeg",

+            "-ss", str(start_time),

+            "-t", str(duration),

+            "-i", path,

+            "-vf", "showinfo",

+            "-f", "null", "-"

+        ]

+

+        try:

+            result = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

+            output = result.stdout

+

+            keyframes = []

+

+            for line in output.splitlines():

+                if "iskey:1 type:I" in line:

+                    parts = line.split("pts_time:")

+                    if len(parts) > 1:

+                        timestamp_str = parts[1].split()[0]

+                        timestamp = float(timestamp_str) + start_time

+                        keyframes.append(timestamp)

+

+            Brint(f"‚úÖ Keyframes autour de {center_time_sec:.3f}s : {keyframes}")

+            return keyframes

+

+        except Exception as e:

+            Brint(f"‚ùå Erreur extraction keyframes autour de {center_time_sec:.3f}s: {e}")

+            return []

+


>> detect_multiple_beat1 (delta: 47)
--- 
+++ 
@@ -16,20 +16,21 @@
     for offset in np.arange(0, duration - segment_duration, step):

         Brint(f"\nüîç Analyse segment {offset:.2f}s ‚Üí {offset + segment_duration:.2f}s")

 

-        # Use the utility function for extraction

-        tmp_path = _util_extract_audio_segment(

-            source_path=path,

-            output_path=None, # Let the utility create a temp file

-            start_sec=offset,

-            duration_sec=segment_duration,

-            channels=1,

-            sample_rate=sr,

-            use_temp_file=True

-        )

-

-        if not tmp_path:

-            Brint(f"‚ùå √âchec de l'extraction audio pour segment {offset:.2f}s dans detect_multiple_beat1")

-            continue # Skip to next segment

+        # d√©coupage audio temporaire

+        tmp_wav = tempfile.NamedTemporaryFile(suffix=".wav", delete=False)

+        tmp_path = tmp_wav.name

+        tmp_wav.close()

+        cmd = [

+            "ffmpeg", "-y",

+            "-ss", str(offset),

+            "-t", str(segment_duration),

+            "-i", path,

+            "-vn",

+            "-ac", "1",

+            "-ar", str(sr),

+            tmp_path

+        ]

+        subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

 

         try:

             y, sr = librosa.load(tmp_path, sr=sr)

@@ -40,7 +41,7 @@
                 Brint("    ‚ö†Ô∏è Segment vide ou trop court.")

                 continue

 

-            tempo, beats = _util_get_tempo_and_beats_librosa(y_data=y, sr_data=sr)

+            tempo, beats = librosa.beat.beat_track(y=y, sr=sr)

             if len(beats) >= min_beats:

                 beat_times = librosa.frames_to_time(beats, sr=sr)

                 beat1_abs = float(beat_times[0] + offset)


>> export_loop_to_file (delta: 44)
--- 
+++ 
@@ -86,29 +86,18 @@
                 loop_x10 = loop * 10

                 loop_x10.export(output_path, format="wav")

             else:

-                # Use the utility function for simple audio segment extraction

-                extracted_path = _util_extract_audio_segment(

-                    source_path=self.current_path,

-                    output_path=output_path,

-                    start_sec=start_sec,

-                    duration_sec=duration_sec,

-                    audio_codec="pcm_s16le",

-                    sample_rate=48000,

-                    channels=2,

-                    overwrite=True,

-                    use_temp_file=False # output_path is provided

-                )

-                if not extracted_path:

-                    Brint(f"‚ùå √âchec de l'export audio (video=False, repeat=False) dans export_loop_to_file")

-                    self.console.config(text="‚ùå Erreur export audio")

-                    # If GDrive, the temp output_path might still exist but be empty, 

-                    # so ensure it's cleaned up or not uploaded if extraction failed.

-                    if destination == 'gdrive' and os.path.exists(output_path):

-                        try:

-                            os.remove(output_path)

-                        except OSError as e:

-                            Brint(f"Could not remove failed export at {output_path}: {e}")

-                    return # Stop further processing for this case

+                cmd = [

+                    "ffmpeg", "-y",

+                    "-ss", str(start_sec),

+                    "-t", str(duration_sec),

+                    "-i", self.current_path,

+                    "-vn",

+                    "-acodec", "pcm_s16le",

+                    "-ar", "48000",

+                    "-ac", "2",

+                    output_path

+                ]

+                subprocess.run(cmd)

 

         if destination == 'disk':

             self.console.config(text=f"‚úÖ Export√© : {os.path.basename(output_path)}")


>> extract_audio_to_wav (delta: 42)
--- 
+++ 
@@ -10,22 +10,22 @@
         start_sec = self.loop_start / 1000.0

         duration_sec = (self.loop_end - self.loop_start) / 1000.0

 

-        extracted_path = _util_extract_audio_segment(

-            source_path=self.current_path,

-            output_path=temp_audio_path, # Specify output path

-            start_sec=start_sec,

-            duration_sec=duration_sec,

-            audio_codec="pcm_s16le", # Default, but explicit

-            sample_rate=48000,       # Specific to this method

-            channels=2,              # Specific to this method

-            overwrite=True,

-            use_temp_file=False      # We are providing a specific output path

-        )

-

-        if extracted_path:

-            Brint(f"[AUDIO] WAV temporaire extrait : {extracted_path}")

-            return extracted_path

-        else:

-            Brint(f"[AUDIO] Erreur extraction WAV via _util_extract_audio_segment")

+        cmd = [

+            "ffmpeg", "-y",

+            "-i", self.current_path,

+            "-ss", str(start_sec),

+            "-t", str(duration_sec),

+            "-vn",

+            "-acodec", "pcm_s16le",

+            "-ar", "48000",

+            "-ac", "2",

+            temp_audio_path

+        ]

+        try:

+            subprocess.run(cmd, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

+            Brint(f"[AUDIO] WAV temporaire extrait : {temp_audio_path}")

+            return temp_audio_path

+        except Exception as e:

+            Brint(f"[AUDIO] Erreur extraction WAV : {e}")

             return None

 


>> detect_tempo_and_beats (delta: 38)
--- 
+++ 
@@ -9,14 +9,9 @@
         Brint(f"=== Analyse tempo sur {audio_path} ===")

         Brint(f"Loop : {loop_start:.2f}s ‚Üí {loop_end:.2f}s")

 

-        # Use the new utility function

-        tmp_path = _util_extract_audio_segment(source_path=audio_path, 

-                                               start_sec=loop_start, 

-                                               duration_sec=duration,

-                                               sample_rate=22050, # Match old sr

-                                               channels=1) 

+        tmp_path = extract_audio_segment(audio_path, loop_start, duration)

         pass #Brint(f"[DEBUG] Fichier temporaire cr√©√© : {tmp_path}")

-        if not tmp_path or not os.path.exists(tmp_path) or os.path.getsize(tmp_path) == 0:

+        if not os.path.exists(tmp_path) or os.path.getsize(tmp_path) == 0:

             Brint("‚ùå Fichier audio temporaire vide ou manquant.")

             return

 

@@ -49,9 +44,9 @@
         idx_start = int((beat1_time - loop_start) * sr)

         y_focus = y[idx_start:idx_start + int(15 * sr)]

 

-        tempo_raw, _ = _util_get_tempo_and_beats_librosa(y_data=y_focus, sr_data=sr)

-        tempo = float(tempo_raw/3)  # mesure?beat? # This division by 3 seems specific, keeping it.

-        Brint(f"üéµ Tempo beats estim√©  : {tempo:.2f} BPM (via _util_get_tempo_and_beats_librosa)")

+        tempo_raw, _ = librosa.beat.beat_track(y=y_focus, sr=sr)

+        tempo = float(tempo_raw/3)  # mesure?beat?

+        Brint(f"üéµ Tempo beats estim√©  : {tempo:.2f} BPM")

 

         os.remove(tmp_path)

         Brint(f"[TIMER] detect_tempo_and_beats: {time.time() - start:.2f}s")

@@ -94,5 +89,4 @@
 FRAME_LENGTH = 1024

 HOP_LENGTH = 256

 

-# Removed unused seconds_to_hms function

 


>> open_given_file (delta: 36)
--- 
+++ 
@@ -1,6 +1,5 @@
     def open_given_file(self, path):

         """Charge un fichier donn√© directement, sans repasser par le file dialog."""

-        self._cleanup_on_exit() 

         self.current_path = path

         self.root.after(1000, self.load_screen_zoom_prefs)

 

@@ -27,6 +26,26 @@
         self.safe_update_playhead(0, source="open_given_file2")

         self.root.after(100, self.update_loop)

         self.console.config(text=f"‚ñ∂Ô∏è Playing: {os.path.basename(path)}")

+        

+        # Calculate and store RMS data

+        try:

+            # Reset previous data first

+            self.waveform_rms_data = None

+            self.waveform_rms_hop_length = None

+            self.audio_sr = None

+            

+            rms_data_tuple = self.get_waveform_rms_data(self.current_path)

+            if rms_data_tuple and rms_data_tuple[0] is not None:

+                self.waveform_rms_data, self.waveform_rms_hop_length, self.audio_sr = rms_data_tuple

+                Brint(f"[RMS] RMS data loaded for {self.current_path}: {len(self.waveform_rms_data)} points, sr={self.audio_sr}, hop={self.waveform_rms_hop_length}")

+            else:

+                Brint(f"[RMS] RMS data could not be generated for {self.current_path} (result was None or rms_data was None)")

+        except Exception as e:

+            Brint(f"[RMS] Error during RMS data generation in open_given_file: {e}")

+            self.waveform_rms_data = None

+            self.audio_sr = None

+            self.waveform_rms_hop_length = None

+

         import threading

         threading.Thread(target=self._run_beat1_detection_from_scanfile, daemon=True).start()

 


>> find_beat1_hotspots (delta: 35)
--- 
+++ 
@@ -1,20 +1,19 @@
 def find_beat1_hotspots(path, sr=22050):

     Brint(f"\nüìÇ Analyse globale pour hotspots jamtrack : {path}")

 

-    # 1. Convertir fichier complet en .wav mono via _util_extract_audio_segment

-    tmp_path = _util_extract_audio_segment(

-        source_path=path,

-        output_path=None, # Let the utility create a temp file

-        start_sec=0,      # From the beginning

-        duration_sec=None, # Until the end

-        channels=1,

-        sample_rate=sr,   # Use the provided sample rate

-        use_temp_file=True

-    )

+    # 1. Convertir fichier complet en .wav mono via ffmpeg

+    tmp_wav = tempfile.NamedTemporaryFile(suffix=".wav", delete=False)

+    tmp_path = tmp_wav.name

+    tmp_wav.close()

 

-    if not tmp_path:

-        Brint(f"‚ùå √âchec de la conversion audio compl√®te pour find_beat1_hotspots via _util_extract_audio_segment")

-        return [] # Or handle error appropriately

+    cmd = [

+        "ffmpeg", "-y",

+        "-i", path,

+        "-ac", "1",

+        "-ar", str(sr),

+        tmp_path

+    ]

+    subprocess.run(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

 

     try:

         y, sr = librosa.load(tmp_path, sr=sr)


>> run_for_5s (delta: 26)
--- 
+++ 
@@ -1,10 +1,15 @@
-    def run_for_5s():

-        start = time.time()

-        while time.time() - start < 5:

-            app.update_playhead_by_time(app.player.get_time())  # üîÅ Utilise `app`, pas `player` ni `self`

-            time.sleep(0.015)  # ~30 FPS

+        def run_for_5s():

+            start = time.time()

+            while time.time() - start < 5:

+                # self.update_playhead_by_time(self.player.get_time())

+                self.safe_update_playhead(self.player.get_time(), source="run_for_5s")

+                time.sleep(0.015)

 

-    # cProfile.runctx('run_for_5s()', globals(), locals(), filename='perf5s.stats')

-    # pstats.Stats("perf5s.stats").sort_stats("cumtime").print_stats(30)

+        Brint("üü° Profiling pendant 5 secondes...")

+        cProfile.runctx("run_for_5s()", globals(), locals(), filename="perf5s.stats")

+        Brint("‚úÖ Profil termin√© ‚Üí perf5s.stats")

+        pstats.Stats("perf5s.stats").sort_stats("cumtime").print_stats(30)

 

-    root.mainloop()

+

+

+


>> detect_jamtrack_zones (delta: 23)
--- 
+++ 
@@ -1,19 +1,6 @@
 def detect_jamtrack_zones(path, sr=22050):

     Brint(f"\nüìÇ Fichier √† analyser : {path}")

-    # Use the utility function for extraction

-    tmp_path = _util_extract_audio_segment(

-        source_path=path,

-        output_path=None, # Let the utility create a temp file

-        start_sec=0.0,

-        duration_sec=180.0,

-        sample_rate=sr,

-        channels=1, # Assuming mono for this analysis

-        use_temp_file=True

-    )

-    if not tmp_path:

-        Brint(f"‚ùå √âchec de l'extraction audio pour detect_jamtrack_zones via _util_extract_audio_segment")

-        return []

-        

+    tmp_path = extract_audio_segment(path, offset=0.0, duration=180.0, sr=sr)

     Brint(f"üéß Segment audio temporaire g√©n√©r√© : {tmp_path}")

 

     try:


>> tap_tempo (delta: 23)
--- 
+++ 
@@ -4,15 +4,13 @@
         self.tap_times.append(now)

         if len(self.tap_times) > 8:

             self.tap_times.pop(0)

-

         if len(self.tap_times) >= 2:

             intervals = [self.tap_times[i+1] - self.tap_times[i] for i in range(len(self.tap_times)-1)]

             avg_interval = sum(intervals) / len(intervals)

             if avg_interval > 0:

-                raw_bpm = 60.0 / avg_interval

-                playback_rate = self.player.get_rate() if self.player else 1.0

-                corrected_bpm = round(raw_bpm / playback_rate, 2)

-                self.set_tempo_bpm(corrected_bpm, source="tap")

-                Brint(f"[TAP TEMPO] üß† Raw BPM = {raw_bpm:.2f} | Playback rate = {playback_rate:.2f} ‚Üí BPM corrig√© = {corrected_bpm:.2f}")

+                tempo = 60.0 / avg_interval

+                self.set_tempo_bpm(tempo, source="tap")

 

-    @property

+    

+    

+


>> apply_all_and_close (delta: 22)
--- 
+++ 
@@ -53,8 +53,8 @@
                 Brint("[SAVE] ‚úÖ Boucle courante sauvegard√©e")

             else:

                 Brint("[SAVE] ‚ùå Fonction save_current_loop non disponible")

-            

-            _on_chord_editor_close()

+

+            popup.destroy()

 

 

         for measure_index in range(total_measures):

@@ -131,7 +131,7 @@
 

                 syllabe = syllables[syll_in_beat] if syll_in_beat < len(syllables) else ""

                 note_strs = [n["note"] if isinstance(n, dict) else str(n) for n in notes_list]

-                Brint(f"[CHORD EDITOR] S{subdiv_index} | t={format_time(t_ms / 1000.0, include_tenths=True)} | Beat={beat_in_measure} | Syllabe={syllabe} | Notes={','.join(note_strs)}")

+                Brint(f"[CHORD EDITOR] S{subdiv_index} | t={self.hms(t_ms)} | Beat={beat_in_measure} | Syllabe={syllabe} | Notes={','.join(note_strs)}")

                 # Afficher la syllabe seule

                 tk.Label(col, text=syllabe, font=("Arial", 9)).pack()

 


>> update_all_detected_notes_from_master (delta: 20)
--- 
+++ 
@@ -11,7 +11,7 @@
         Brint("[DEBUG] üîç master_note_list (extrait) :")

         for note in source[:20]:

             start, end, pitch, conf = note

-            Brint(f"- {format_time(start, include_tenths=True)} ‚Üí {format_time(end, include_tenths=True)} | Pitch: {pitch} | Confidence: {conf:.2f}")

+            Brint(f"- {self.hms(start * 1000)} ‚Üí {self.hms(end * 1000)} | Pitch: {pitch} | Confidence: {conf:.2f}")

 

         for i in range(len(self.grid_times)):

             t0 = self.grid_times[i]

@@ -22,7 +22,7 @@
                 if not (end < t0 or start >= t1)

             ]

             self.all_detected_notes.append(group)

-            Brint(f"[DEBUG] Subdiv {i:02d} ({format_time(t0, include_tenths=True)} ‚Üí {format_time(t1, include_tenths=True)}) ‚Üí {len(group)} note(s)")

+            Brint(f"[DEBUG] Subdiv {i:02d} ({self.hms(t0 * 1000)} ‚Üí {self.hms(t1 * 1000)}) ‚Üí {len(group)} note(s)")

 

         pass#Brint(f"[RHYTHM] üéØ Notes recalcul√©es pour {len(self.grid_times)} subdivisions")

 


>> Brint (delta: 16)
--- 
+++ 
@@ -6,12 +6,8 @@
     tags = re.findall(r"\[(.*?)\]", first_arg)

 

     # üîí Mode silencieux global : BRINT = False d√©sactive TOUT

-    if DEBUG_FLAGS.get("BRINT", None) is None:

+    if DEBUG_FLAGS.get("BRINT", None) is False:

         return

-

-    # üîí Mode silencieux global : BRINT = False d√©sactive TOUT

-    if DEBUG_FLAGS.get("BRINT", None) is False:

-        pass

 

     # üí• Mode super-debug : BRINT = True affiche tout

     if DEBUG_FLAGS.get("BRINT", None) is True:


>> set_selected_loop_name (delta: 13)
--- 
+++ 
@@ -1,6 +1,7 @@
     def set_selected_loop_name(self, name, loop_start=None, loop_end=None, source="(non sp√©cifi√©)"):

-        a_s = loop_start / 1000.0 if loop_start is not None else -1 # Use -1 for None for format_time

-        b_s = loop_end / 1000.0 if loop_end is not None else -1

-        Brint(f"[TRACE] set_selected_loop_name = '{name}' (A={format_time(a_s, include_tenths=True)}, B={format_time(b_s, include_tenths=True)}) depuis {source}")

+        a_ms = loop_start if loop_start is not None else "N/A"

+        b_ms = loop_end if loop_end is not None else "N/A"

+        # Brint(f"[TRACE] set_selected_loop_name = '{name}' (A={a_ms}ms, B={b_ms}ms) depuis {source}")

+        Brint(f"[TRACE] set_selected_loop_name = '{name}' (A={self.hms(a_ms)}ms, B={self.hms(b_ms)}ms) depuis {source}")

         self.selected_loop_name = name

 


>> save_current_loop (delta: 12)
--- 
+++ 
@@ -9,8 +9,7 @@
             Brint(f"[WARNING] Sauvegarde annul√©e : loop_start={self.loop_start}, loop_end={self.loop_end}")

             return

 

-        top = Toplevel(self.root) 

-        top.transient(self.root)

+        top = Toplevel()

         top.title("Sauvegarder ou Remplacer une boucle")

         Brint("[SAVE LOOP] Fen√™tre de sauvegarde ouverte")

         Label(top, text="Clique sur une boucle pour la remplacer, ou entre un nouveau nom:").pack(pady=5)


>> delete_selected_loop (delta: 12)
--- 
+++ 
@@ -2,8 +2,7 @@
         if not self.saved_loops:

             self.console.config(text="‚ö†Ô∏è Aucune boucle √† supprimer")

             return

-        top = Toplevel(self.root) 

-        top.transient(self.root)

+        top = Toplevel()

         top.title("Supprimer une boucle")

         Label(top, text="S√©lectionne une boucle √† supprimer:").pack(pady=5)

         listbox = Listbox(top, selectmode=SINGLE)


>> build_grid_times_from_loop (delta: 11)
--- 
+++ 
@@ -23,7 +23,7 @@
             t = start_sec + (i / subdivs_per_beat) * (60.0 / bpm)

             grid_times.append(t)

             if i < 5:

-                Brint(f"[build_grid_times_from_loop] ‚ñ∂ Subdiv {i} = {format_time(t, include_tenths=True)}")

+                Brint(f"[build_grid_times_from_loop] ‚ñ∂ Subdiv {i} = {self.hms(t * 1000)}")

         

         Brint(f"[build_grid_times_from_loop] ‚úÖ Fin : {len(grid_times)} subdivisions totales")

         return grid_times


>> cycle_subdivision_mode_backward (delta: 11)
--- 
+++ 
@@ -16,7 +16,7 @@
         Brint("[DEBUG] üîç master_note_list (extrait) :")

         for note in self.current_loop_master_notes[:10]:

             start, end, pitch, conf = note

-            Brint(f" - {format_time(start, include_tenths=True)} | Pitch: {pitch} | Confidence: {conf:.2f}")

+            Brint(f" - {self.hms(start * 1000)} | Pitch: {pitch} | Confidence: {conf:.2f}")

         

         self.refresh_note_display()

         self.draw_rhythm_grid_canvas()


>> get_rhythm_levels (delta: 11)
--- 
+++ 
@@ -17,7 +17,7 @@
             "64th": base_beat / (24 if rhythm_type == "ternary" else 16)

 

         }

-        Brint(f"[SCORE jumps] RHYTHMe jump ‚Üí BPM={bpm:.2f} | bar={levels['bar']} | beat={levels['beat']}")

+        Brint(f"[DEBUG] RHYTHMe jump ‚Üí BPM={bpm:.2f} | bar={levels['bar']} | beat={levels['beat']}")

 

 

         return levels


>> build_rhythm_grid (delta: 11)
--- 
+++ 
@@ -50,7 +50,7 @@
             label = f"{beat}{suffix}"

             self.grid_labels.append(label)

             if i < 5:

-                pass#Brint(f"[BRG DEBUG] i={i} | t={format_time(t, include_tenths=True)} hms")

+                pass#Brint(f"[BRG DEBUG] i={i} | t={self.hms(1000 * t)} hms")

 

 

         pass#Brint(f"[BRG RHYTHM] ‚úÖ Grille g√©n√©r√©e : {len(self.grid_labels)} subdivisions ({mode})")


>> _disable_tempo_edit (delta: 11)
--- 
+++ 
@@ -1,8 +1,4 @@
     def _disable_tempo_edit(self):

-        if hasattr(self, "_tempo_cooldown_id") and self._tempo_cooldown_id:

-            self.root.after_cancel(self._tempo_cooldown_id)

-            self._tempo_cooldown_id = None

-            Brint("[TEMPO EDIT] Cooldown timer cancelled by explicit disable.")

         self.tempo_entry.config(state="readonly")

         self.console.config(text="‚è≤Ô∏è Champ tempo d√©sactiv√© (tape pour r√©√©diter)")

 


>> quick_save_current_loop (delta: 9)
--- 
+++ 
@@ -29,6 +29,3 @@
     

         

 

-    # Removed VideoPlayer.hms and VideoPlayer.hms_from_seconds

-    # Global hms_to_seconds is kept for now.

-


>> snap_time_to_grid (delta: 9)
--- 
+++ 
@@ -5,4 +5,5 @@
         delta = self.get_jump_duration_ms(level)

         snapped = round(time_ms / delta) * delta

         return int(snapped)

-        

+

+


>> on_frame_configure (delta: 9)
--- 
+++ 
@@ -1,4 +1,5 @@
         def on_frame_configure(event):

-            self._chord_editor_canvas.configure(scrollregion=self._chord_editor_canvas.bbox("all"))

+            canvas.configure(scrollregion=canvas.bbox("all"))

         scrollable_frame.bind("<Configure>", on_frame_configure)

 

+        # Support molette souris


>> open_save_menu (delta: 9)
--- 
+++ 
@@ -1,6 +1,5 @@
     def open_save_menu(self):

         menu = Toplevel(self.root)

-        menu.transient(self.root)

         menu.title("Sauvegarder la boucle")

         menu.geometry("+300+300")

 


>> show_open_menu (delta: 9)
--- 
+++ 
@@ -1,6 +1,5 @@
     def show_open_menu(self):

         top = Toplevel(self.root)

-        top.transient(self.root)

         top.title("Ouvrir un fichier")

         Label(top, text="üìÅ Choisir un fichier").pack(pady=5)

 


>> hms_to_seconds (delta: 8)
--- 
+++ 
@@ -1,4 +1,4 @@
-    def hms_to_seconds(hms): 

+    def hms_to_seconds(hms):

         parts = list(map(float, hms.split(":")))

         return sum(t * 60**i for i, t in enumerate(reversed(parts)))

 


>> load_saved_loop (delta: 8)
--- 
+++ 
@@ -60,4 +60,4 @@
         self.update_tempo_ui_from_loop()

 

         Brint(f"[‚úÖ DONE] Boucle '{self.current_loop.name}' charg√©e avec succ√®s")

-        Brint(f"[DEBUG] A={format_time(self.loop_start / 1000.0, include_tenths=True)} | B={format_time(self.loop_end / 1000.0, include_tenths=True)} | BPM={self.tempo_bpm}")

+        Brint(f"[DEBUG] A={self.hms(self.loop_start)} | B={self.hms(self.loop_end)} | BPM={self.tempo_bpm}")


========== FONCTIONS LI√âES AU MOT-CL√â ==========

>> open_given_file
    def open_given_file(self, path):
        """Charge un fichier donn√© directement, sans repasser par le file dialog."""
        self.current_path = path
        self.root.after(1000, self.load_screen_zoom_prefs)


        # --- faststart remux (si tu veux le garder)
        # self.faststart_remux(path)  # D√©commente si besoin

        self.media = self.instance.media_new(path)
        self.load_saved_loops()
        self.player.set_media(self.media)
        self.player.set_hwnd(self.canvas.winfo_id())
        self.apply_crop()

        self.playhead_time = 0.0
        self.last_jump_target_ms = 0
        self.safe_update_playhead(0, source="open_given_file")

        self.player.play()
        self.root.after(1000, self.reset_force_playhead_time)

        if hasattr(self, "player"):
            self.player.audio_set_mute(False)

        self.safe_update_playhead(0, source="open_given_file2")
        self.root.after(100, self.update_loop)
        self.console.config(text=f"‚ñ∂Ô∏è Playing: {os.path.basename(path)}")
        
        # Calculate and store RMS data
        try:
            # Reset previous data first
            self.waveform_rms_data = None
            self.waveform_rms_hop_length = None
            self.audio_sr = None
            
            rms_data_tuple = self.get_waveform_rms_data(self.current_path)
            if rms_data_tuple and rms_data_tuple[0] is not None:
                self.waveform_rms_data, self.waveform_rms_hop_length, self.audio_sr = rms_data_tuple
                Brint(f"[RMS] RMS data loaded for {self.current_path}: {len(self.waveform_rms_data)} points, sr={self.audio_sr}, hop={self.waveform_rms_hop_length}")
            else:
                Brint(f"[RMS] RMS data could not be generated for {self.current_path} (result was None or rms_data was None)")
        except Exception as e:
            Brint(f"[RMS] Error during RMS data generation in open_given_file: {e}")
            self.waveform_rms_data = None
            self.audio_sr = None
            self.waveform_rms_hop_length = None

        import threading
        threading.Thread(target=self._run_beat1_detection_from_scanfile, daemon=True).start()

        if dbflag:
            pass #Brint(f"[DEBUG] open_given_file(): tentative de get_length() = {self.player.get_length()} ms")

        self.add_recent_file(path)
    
    
